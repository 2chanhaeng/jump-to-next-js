# 로그인 및 비로그인 별 기능 구분하기

## 목차

- [로그인 및 비로그인 별 기능 구분하기](#로그인-및-비로그인-별-기능-구분하기)
  - [목차](#목차)
  - [로그인과 비로그인](#로그인과-비로그인)
  - [경로 접근 제한](#경로-접근-제한)
    - [Middleware](#middleware)
    - [`auth`](#auth)
    - [`callbacks`](#callbacks)
    - [`authorized`](#authorized)
    - [인증 정보 확인하기](#인증-정보-확인하기)
    - [일부 경로에서 비로그인 시 로그인 요청하기](#일부-경로에서-비로그인-시-로그인-요청하기)
    - [로그인 상태에서 일부 경로 접근 제한하기](#로그인-상태에서-일부-경로-접근-제한하기)

## 로그인과 비로그인

만약 사용자가 로그인을 했는데 다시 회원가입이나 로그인이 된다면 문제가 발생할 수 있다.
혹은 반대로 로그인을 하지 않았는데 로그아웃이나 글을 쓰는 것이 가능하다면 문제가 발생할 수 있다.  
따라서 로그인과 비로그인 상태를 구분해서 기능을 구현해야 한다.

## 경로 접근 제한

상태에 따라 접근 가능한 경로 자체를 제한해야 하는 경우가 있다.  
예를 들어 비로그인 상태에서 글을 쓰는 `/questions/new` 에 접근하거나 로그인 상태에서 로그인이나 회원가입을 하는 경로로 접근 하는 것은 막아햐 할 것이다.

### Middleware

이를 위해서는 먼저 [`middleware.ts`](https://nextjs.org/docs/app/building-your-application/routing/middleware) 를 설정해야한다.  
`middleware.ts` 는 Next.js 에서 제공하는 미들웨어를 설정하는 파일이다.

```ts
// middleware.ts
import { auth } from "@/auth";

export default auth;

export const config = {
  // https://nextjs.org/docs/app/building-your-application/routing/middleware#matcher
  matcher: ["/((?!api|_next/static|_next/image|.*\\.png$).*)"],
};
```

`auth/index.ts` 에서 내보낸 `auth` 를 `middleware.ts` 에서 가져와서 내보낸다.
`matcher` 는 미들웨어를 적용할 경로를 정의한다.

### `auth`

그런데 사실 우리는 아직 `auth/index.ts` 에서 `auth` 를 내보내지 않았다.  
`auth/index.ts`에 가서 `auth` 를 내보내보자.

```ts
// auth/index.ts
...
export const { handlers, signOut, auth } = NextAuth({ ... });
```

### `callbacks`

그리고 `auth/index.ts` 의 `NextAuth`에 `callbacks` 를 추가한다.

```ts
...
export const { handlers, signOut, auth } = NextAuth({
  ...,
  callbacks: {}
});
```

`callbacks` 에는 인증 시 필요한 콜백 함수들을 정의하는 곳이다.

### `authorized`

그 중에서 우리가 지금 필요한 것은 `authorized` 이다.  
`authorized` 는 반환되는 `boolean` 값에 따라 접근 가능한 경로를 제한할 수 있다.  
예를 들어 상태에 관계 없이 모든 경로를 접근 금지 시키고 싶다면 아래와 같이 작성하면 된다.

```ts
export const { handlers, signOut, auth } = NextAuth({
  ...,
  callbacks: {
    authorized() {
      return false;
    }
  }
});
```

만약 로그인 상태에 따라 다르게 설정하고 싶다고 하자.

### 인증 정보 확인하기

이를 판단하기 위해서는 현재 인증 정보에 유저가 존재하는지 판단하면 된다.  
인증 정보는 `authorized` 의 첫번째 인자 `params`의 `auth` 에 존재한다.

```ts
authorized({ auth }) {
  const isLoggedIn = !!auth?.user;
  return isLoggedIn;
},
```

이 상태로 아무 페이지나 들어가보자.  
만약 로그인된 상태라면 어느 페이지든 문제 없이 접근 가능하고, 그렇지 않다면 로그인 페이지로 이동하게 될 것이다.

### 일부 경로에서 비로그인 시 로그인 요청하기

물론 비회원을 강제로 로그인 시켜도 좋지만 일부 사용자들은 정보를 보기 위해 회원가입을 귀찮아 할 수 있다.  
글을 보기만 하는 경우에는 로그인을 강제하지 않고, 글을 쓰는 경우에만 로그인을 요청하는 것이 좋을 것이다.  
따라서 경로에 따라 로그인을 요구하는 경우와 그렇지 않은 경우를 구분해야 한다.  
즉, 사용자가 접근한 경로를 알아야 한다.
이 값은 `params`의 `request` 의 `nextUrl` 에 들어있다.  
이를 이용해서 경로에 따라 다르게 동작하도록 구현해보자.

```ts
authorized({ auth, request: { nextUrl } }) {
  const isLoggedIn = !!auth?.user;
  const isLoginNeeded = nextUrl.pathname.startsWith("/questions/new");
  if (isLoginNeeded) return isLoggedIn;
  return true;
},
```

만약 사용자가 `/questions/new` 로 시작하는 경로로 접근한다면 `isLoginNeeded` 값이 `true` 가 될 것이다.  
이 상태로 `/questions/new` 에 접근한 경우 로그인한 경우 평소처럼 새 글 쓰기 페이지가 보일 것이고, 그렇지 않은 경우 로그인 페이지로 이동하게 될 것이다.

### 로그인 상태에서 일부 경로 접근 제한하기

반대로 비로그인 상태에서만 접근할 수 있는 경로는 어떻게 제한할까?  
예를 들어 로그인한 상태에서 로그인 페이지(`/api/auth/signin`)나 회원가입 페이지(`/signup`)로 접근하는 것을 막고 싶다고 하자.  
아마 이런 식으로 코드를 작성하면 되지 않을까?

```ts
authorized({ auth, request: { nextUrl } }) {
  ...
  if (isLoginNeeded) return isLoggedIn;
  const isLogoutNeeded =
    nextUrl.pathname.startsWith("/api/auth/signin") ||
    nextUrl.pathname.startsWith("/signup");
  if (isLogoutNeeded) return !isLoggedIn;
  return true;
},
```

하지만 이렇게까지만 작성하면 로그인한 유저를 다시 로그인 페이지로 보내는 문제가 발생한다.  
즉, 로그인한 유저를 처리할 때는 단순히 `false` 값이 아니라 다른 페이지로 보내는 것이 좋다.  
이를 위해서는 `Response` 의 `redirect` 를 사용하면 된다.

```ts
...
if (isLogoutNeeded && isLoggedIn)
  return Response.redirect(new URL("/", nextUrl));
...
```
